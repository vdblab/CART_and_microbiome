[["index.html", "CART microbiome analysis Chapter 1 Prerequisites", " CART microbiome analysis Anqi Dai 2021-09-03 Chapter 1 Prerequisites install.packages(&quot;bookdown&quot;) "],["intro.html", "Chapter 2 Introduction", " Chapter 2 Introduction You can label chapter and section titles using {#label} after them, e.g., we can reference Chapter 2. If you do not manually label them, there will be automatic labels anyway, e.g., Chapter 4. Figures and tables with captions will be placed in figure and table environments, respectively. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 2.1: Here is a nice figure! Reference a figure by its code chunk label with the fig: prefix, e.g., see Figure 2.1. Similarly, you can reference tables generated from knitr::kable(), e.g., see Table 2.1. knitr::kable( head(iris, 20), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 2.1: Here is a nice table! Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa You can write citations, too. For example, we are using the bookdown package (Xie 2021) in this sample book, which was built on top of R Markdown and knitr (Xie 2015). References "],["fig-3.html", "Chapter 3 Fig 3 3.1 3B: stacked bar chart. 3.2 3C: alpha and beta diversity between CART patients and healthy volunteers 3.3 Fig 3 E&amp;F Lefse analysis with taxa abundance at ASV level 3.4 Fig 3D Bayesian modeling with microbiome alpha diversity as predictor 3.5 Fig 3G Bayesian modeling with 5 genera abundance as predictor(outcome CR) 3.6 Fig3H Histogram to illustrate the predicted probability of day100 CR 3.7 Fig 3I Bayesian modeling with 5 genera abundance as predictor(outcome toxicity) 3.8 Fig3J Histogram to illustrate the predicted probability of toxicity 3.9 Fig 3K lefse of pathway abundance using shotgun data", " Chapter 3 Fig 3 3.1 3B: stacked bar chart. library(tidyverse) library(vdbR) library(ggpubr) connect_database(&#39;~/dbConfig.txt&#39;) get_table_from_database(&quot;asv_annotation_blast_color_ag&quot;); # my table of the CART stool cohort stb &lt;- read_csv(&#39;data/amplicon/stool/combined_2_meta.csv&#39;) # get the counts from database and also the color for the asv counts_data &lt;- get_counts_subset(stb$sampleid) dat &lt;- counts_data %&gt;% select(asv_key:count_total, count_relative) %&gt;% left_join(asv_annotation_blast_color_ag %&gt;% select(asv_key,color_label_group_distinct), by = &quot;asv_key&quot;) # there are some ASVs that don&#39;t have a color with it, but can use the color for the genus level color_group &lt;- dat %&gt;% split(is.na(.$color_label_group_distinct)) # find the genus for these asv get_table_from_database(&#39;asv_annotation_blast_ag&#39;) no_color &lt;- color_group %&gt;% pluck(&#39;TRUE&#39;) %&gt;% distinct(asv_key) %&gt;% inner_join(asv_annotation_blast_ag %&gt;% select(asv_key, genus)) # find the colors for these genera genera_colors &lt;- no_color %&gt;% distinct(genus) %&gt;% inner_join(asv_annotation_blast_color_ag %&gt;% distinct(genus, color_label_group_distinct)) # the full df for the no color genera no_color_df &lt;- no_color %&gt;% left_join(genera_colors) no_color_df_full &lt;- color_group %&gt;% pluck(&#39;TRUE&#39;) %&gt;% select(-color_label_group_distinct) %&gt;% left_join(no_color_df %&gt;% select(- genus)) # so if the genus is unknown then it&#39;s gonna be assigned &quot;other&quot; gray color # the question is do we go one taxa level higher or make a new color base and shades for the new asv # after discussing with Tsoni, we decided that it&#39;s ok to assign gray to the unknown genus # merge the new no_color_df_full to the original df dat &lt;- bind_rows( no_color_df_full, color_group %&gt;% pluck(&#39;FALSE&#39;) ) dat %&gt;% write_csv(&#39;data/the_data_to_make_panel_B.csv&#39;) # the color palette (inherited from Ying, used in lots of project in our lab, the palette used in the NEJM paper Fig 2D https://www.nejm.org/doi/full/10.1056/NEJMoa1900623) asv_color_set &lt;- asv_annotation_blast_color_ag %&gt;% distinct(color,color_label_group_distinct,color_label_group,color_base) %&gt;% select(color_label_group_distinct, color) %&gt;% deframe() # calculate the beta diversity between the samples which deicide the order of the samples in the plot cbd &lt;- compute_beta_diversity_and_tsne(sampleid = dat$sampleid, taxonomy = dat$color_label_group_distinct, count = dat$count); #compute beta diversity cbd$compute_beta_diversity() ## Time:Composition_matrix: ## Time difference of 0.01121807 secs ## Time:Bray-Curtis matrix: ## Time difference of 0.160646 secs #get beta diversity d_beta &lt;- cbd$get_betadiversity() #compute hierarchical cluster hc &lt;- hclust(as.dist(d_beta), method = &#39;complete&#39;) dend &lt;- as.dendrogram(hc) sample_dendogram_order &lt;- labels(dend) # dividing the samples to lower and higher diversity div_order &lt;- stb %&gt;% arrange(simpson_reciprocal) %&gt;% pull(sampleid) ### # how about splitting the above dendrogram order into the low and higher diversity groups div_med &lt;- median(stb$simpson_reciprocal) lower_samp &lt;- stb %&gt;% filter(simpson_reciprocal &lt;= div_med) %&gt;% pull(sampleid) lower_samp_o &lt;- sample_dendogram_order[sample_dendogram_order %in% lower_samp] higher_samp_o &lt;- sample_dendogram_order[!sample_dendogram_order %in% lower_samp] dat$sampleid = factor(dat$sampleid,levels = c(lower_samp_o, higher_samp_o)) ggplot(dat,aes(sampleid, count_relative, fill = color_label_group_distinct) ) + geom_bar(stat = &quot;identity&quot;, position=&quot;fill&quot;, width = 1) + theme_classic() + labs(title = &#39;&#39;, ylab = &#39;Relative counts&#39;) + theme(axis.text.x = element_text(angle = 90), axis.text.y = element_blank(), legend.position = &quot;none&quot;) + scale_fill_manual(values = asv_color_set) + ggsave(&#39;figs/amplicon/stacked_bar_sorted_with_hclust_lower_and_higher_diversity.pdf&#39;, width = 7, height = 5) 3.2 3C: alpha and beta diversity between CART patients and healthy volunteers 3.2.1 alpha diversity (Simpsonâ€™s reciprocal) library(vdbR) connect_database(&#39;~/dbConfig.txt&#39;) get_table_from_database(&quot;healthy_volunteers_ag&quot;) get_table_from_database(&quot;asv_alpha_diversity_ag&quot;) ## [1] &quot;table asv_alpha_diversity_ag is loaded and filtered for duplicates. Only the replicate of highest coverage is retained.&quot; # a total of 75 samples alpha &lt;- bind_rows( stb %&gt;% select(sampleid, simpson_reciprocal) %&gt;% mutate(grp = &#39;baseline_CART&#39;), asv_alpha_diversity_ag %&gt;% select(sampleid, simpson_reciprocal) %&gt;% inner_join(healthy_volunteers_ag %&gt;% select(sampleid), by = &quot;sampleid&quot;) %&gt;% mutate(grp = &#39;healthy&#39;) ) %&gt;% distinct(sampleid, .keep_all = T) alpha %&gt;% ggboxplot(x = &#39;grp&#39;, y = &#39;simpson_reciprocal&#39;, add = &#39;jitter&#39;, title = &#39;&#39;, ylab = &#39;Fecal diversity (Simpson Reciprocal)&#39;, xlab = &#39;&#39;, palette = c(&#39;#ED0000&#39;,&#39;#00468B&#39;)) + stat_compare_means(comparisons= list(c(&#39;healthy&#39;, &#39;baseline_CART&#39;)), label= &quot;p.format&quot;, method= &#39;wilcox.test&#39;) 3.2.2 beta diversity (PCOA of Bray-Curtis) PCOA of Bray-Curtis distance with counts matrix at ASV level using an abundannce threshold of 0.01% and a prevalence threshold of 25% between healthy and CART cohort. library(vdbR) connect_database(&#39;~/dbConfig.txt&#39;) healthy &lt;- healthy_volunteers_ag %&gt;% inner_join(asv_alpha_diversity_ag, by = c(&quot;sampleid&quot;, &quot;oligos_id&quot;)) cts &lt;- get_counts_subset(c(stb$sampleid, healthy %&gt;% pull(sampleid))) # a total of 75 samples counts. there are 3 healthy samples I don&#39;t have count . nsamp &lt;- cts %&gt;% distinct(sampleid) %&gt;% nrow all_pheno &lt;- bind_rows(healthy %&gt;% select(sampleid) %&gt;% mutate(grp = &#39;healthy&#39;, center = &#39;healthy&#39;), stb %&gt;% select(sampleid, center) %&gt;% mutate(grp = &#39;CART&#39;) %&gt;% select(sampleid, grp, center) ) %&gt;% ungroup %&gt;% distinct(sampleid, .keep_all = T) %&gt;% inner_join(asv_alpha_diversity_ag %&gt;% distinct(sampleid, .keep_all = T) %&gt;% distinct(path_pool, sampleid)) # filter &gt;0.01% in more than 25% samples keepa &lt;- cts %&gt;% filter(count_relative &gt; 0.0001) %&gt;% count(asv_key) %&gt;% filter(n &gt; floor(nsamp * 0.25)) %&gt;% pull(asv_key) cts_fil &lt;- cts %&gt;% filter(asv_key %in% keepa) %&gt;% select(sampleid, asv_key,count_relative ) %&gt;% spread(key = &#39;asv_key&#39;, value = &#39;count_relative&#39;, fill = 0) %&gt;% column_to_rownames(&#39;sampleid&#39;) library(vegan) dist_ &lt;- vegdist(cts_fil, method = &#39;bray&#39;) eigen &lt;- pcoa(dist_)$values$Eigenvalues percent_var &lt;- signif(eigen/sum(eigen), 3)*100 bc &lt;- cmdscale(dist_, k = 2) bc %&gt;% as.data.frame() %&gt;% rownames_to_column(&#39;sampleid&#39;) %&gt;% ungroup() %&gt;% inner_join(all_pheno) %&gt;% distinct() %&gt;% ggscatter(x = &#39;V1&#39;, y = &#39;V2&#39;, color = &#39;grp&#39;) + labs(title = &#39;PCOA of healthy and CART patients&#39;) + xlab(paste0(&quot;PC 1 [&quot;,percent_var[1],&quot;%]&quot;)) + ylab(paste0(&quot;PC 2 [&quot;,percent_var[2],&quot;%]&quot;)) + #theme_void() + ggsave(&#39;figs/PCOA(bray-curtis) of healthy and CART patients.pdf&#39;) The PCOA with only CART patients data using the same filtering threshold but colored with the different pools they are sequenced from. # a pcoa at asv level to show they are from different pools and well mixed cts &lt;- get_counts_subset(c(stb$sampleid)) # filter &gt;0.01% in more than 25% samples keepa &lt;- cts %&gt;% filter(count_relative &gt; 0.0001) %&gt;% count(asv_key) %&gt;% filter(n &gt; floor(nsamp * 0.25)) %&gt;% pull(asv_key) cts_fil &lt;- cts %&gt;% filter(asv_key %in% keepa) %&gt;% select(sampleid, asv_key,count_relative ) %&gt;% spread(key = &#39;asv_key&#39;, value = &#39;count_relative&#39;, fill = 0) %&gt;% column_to_rownames(&#39;sampleid&#39;) dist_ &lt;- vegdist(cts_fil, method = &#39;bray&#39;) eigen &lt;- pcoa(dist_)$values$Eigenvalues percent_var &lt;- signif(eigen/sum(eigen), 3)*100 bc &lt;- cmdscale(dist_, k = 2) mp &lt;- bc %&gt;% as.data.frame() %&gt;% rownames_to_column(&#39;sampleid&#39;) %&gt;% ungroup() %&gt;% inner_join(all_pheno) %&gt;% distinct(sampleid, .keep_all = T) %&gt;% mutate(pool = str_extract(path_pool, &#39;Sample.+/&#39;)) %&gt;% mutate(pool = str_replace(pool, &#39;Sample_&#39;,&#39;&#39;)) %&gt;% mutate(pool = if_else(str_detect(pool, &#39;IGO&#39;), str_extract(pool, &#39;IGO.+$&#39;), pool)) %&gt;% mutate(pool = str_replace(pool, &#39;_1/|_comple.+$&#39;,&#39;&#39;)) mp %&gt;% ggscatter(x = &#39;V1&#39;, y = &#39;V2&#39;, color = &#39;pool&#39;, size = 3) + labs(title = &#39;PCOA of CART patients&#39;) + xlab(paste0(&quot;PC 1 [&quot;,percent_var[1],&quot;%]&quot;)) + ylab(paste0(&quot;PC 2 [&quot;,percent_var[2],&quot;%]&quot;)) + #theme_void() + ggsave(&#39;figs/PCOA(bray-curtis) (ASV level)of CART patients_pool.pdf&#39;, width = 9, height = 9) 3.3 Fig 3 E&amp;F Lefse analysis with taxa abundance at ASV level library(tidyverse) library(ggpubr) # sort out the asv counts table and also do filtering (need to have all taxa levels) meta &lt;- read_csv(&#39;data/amplicon/stool/combined_2_meta.csv&#39;) library(vdbR) connect_database(&#39;~/dbConfig.txt&#39;) get_table_from_database(&#39;asv_annotation_blast_ag&#39;) cts &lt;- get_counts_subset(meta$sampleid) cts_ &lt;- cts %&gt;% select(asv_key, sampleid, count_relative) %&gt;% spread(key = &#39;sampleid&#39;, value = &#39;count_relative&#39;, fill = 0) annot &lt;- asv_annotation_blast_ag %&gt;% filter(asv_key %in% cts_$asv_key) %&gt;% mutate(ordr = if_else(is.na(ordr), str_glue(&#39;unknown_of_class_{class}&#39;), ordr), family = if_else(is.na(family), str_glue(&#39;unknown_of_order_{ordr}&#39;), family), genus = if_else(is.na(genus) , str_glue(&#39;unknown_of_family_{family}&#39;), genus), species = if_else(is.na(species) , str_glue(&#39;unknown_of_genus_{genus}&#39;), species)) %&gt;% mutate(taxa_asv = str_glue(&#39;k__{kingdom}|p__{phylum}|c__{class}|o__{ordr}|f__{family}|g__{genus}|s__{species}|a__{asv_key}&#39;)) cts_all &lt;- cts_ %&gt;% full_join(annot %&gt;% select(asv_key, taxa_asv), by = &#39;asv_key&#39;) %&gt;% select(-asv_key) %&gt;% gather(&#39;sampleid&#39;, &#39;relab&#39;, names(.)[1]:names(.)[ncol(.)-1]) %&gt;% left_join(meta %&gt;% select(sampleid, cr_d100, toxicity), by = &#39;sampleid&#39;) # the asv to keep # keep the asvs that show up in at least 25% of the samples keepg &lt;- cts_all %&gt;% filter(relab &gt; 0.0001) %&gt;% ungroup() %&gt;% count(taxa_asv) %&gt;% filter(n &gt; floor(nrow(meta) * 0.25)) %&gt;% pull(taxa_asv) cts_fil &lt;- cts_all %&gt;% filter(taxa_asv %in% keepg) %&gt;% spread(&#39;sampleid&#39;, &#39;relab&#39;, fill = 0) # the pheno label for the samples pheno &lt;- meta %&gt;% select(center, cr_d100:crs, icans, sampleid) %&gt;% gather(&#39;pheno&#39;, &#39;value&#39;, cr_d100:icans) all_sub_pheno &lt;- pheno %&gt;% split(., list(.$pheno)) %&gt;% purrr::imap(~ filter(.data = ., value != &#39;not_assessed&#39;)) tpheno &lt;- all_sub_pheno %&gt;% imap(function(.x, .y){ select(.data = .x, value) %&gt;% t() %&gt;% write.table(str_glue(&#39;data/amplicon/lefse/pull_{.y}.txt&#39;), sep = &#39;\\t&#39;, quote = F, row.names = T, col.names = F) }) tcts &lt;- all_sub_pheno %&gt;% map(~ pull(.data = ., sampleid) ) %&gt;% imap(~ cts_fil %&gt;% select(taxa_asv, matches(.x)) %&gt;% write_tsv(str_glue(&#39;data/amplicon/lefse/{.y}_asv_tcts.tsv&#39;))) cat data/amplicon/lefse/pull_toxicity.txt data/amplicon/lefse/toxicity_asv_tcts.tsv &gt; data/amplicon/lefse/pull_toxicity_asv_tcts.tsv cat data/amplicon/lefse/pull_cr_d100.txt data/amplicon/lefse/cr_d100_asv_tcts.tsv &gt; data/amplicon/lefse/pull_cr_d100_asv_tcts.tsv fns &lt;- list.files(&#39;data/amplicon/lefse/&#39;, pattern = &#39;pull.*_asv_tcts.tsv$&#39;) cmds &lt;- tibble( fns = fns ) %&gt;% mutate(format_cmd = str_glue(&#39;lefse_format_input.py {fns} {fns}.in -c 1 -u 2 -o 1000000 &#39;)) %&gt;% mutate(run_cmd = str_glue(&#39;lefse_run.py -l 4 {fns}.in {fns}.res&#39;)) %&gt;% mutate(plot_cmd = str_glue(&#39;lefse_plot_res.py {fns}.res {fns}.pdf --format pdf --feature_font_size 4 --width 10 --dpi 300 --title {fns}&#39;)) %&gt;% mutate(clado_cmd = str_glue(&#39;lefse_plot_cladogram.py {fns}.res {fns}_clado.pdf --label_font_size 4 --dpi 300 --format pdf --title {fns}&#39;)) %&gt;% select(-fns) %&gt;% gather() %&gt;% select(value) %&gt;% write_csv(&#39;data/amplicon/lefse/lefse_run_cmd_taxa.sh&#39;, col_names = F) # run in terminal: # bash /Users/daia1/projects/CART_and_microbiome/data/amplicon/lefse/lefse_run_cmd_taxa.sh # visualize the results in ggplot # the input : lefse res files fns &lt;- list.files(&#39;data/amplicon/lefse/&#39;, pattern = &#39;pull.*_asv_tcts.tsv.res$&#39;, full.names = T) # join all of the tables feature together feature &lt;- fns %&gt;% set_names(fns) %&gt;% map(~ read_tsv(., col_names = c(&#39;feature&#39;,&#39;xx&#39;,&#39;direction&#39;,&#39;score&#39;,&#39;pval&#39;)) %&gt;% filter(!is.na(score))) %&gt;% bind_rows(.id = &#39;group&#39;) %&gt;% mutate(group = str_replace(group, &#39;data/amplicon/lefse//pull_&#39;,&#39;&#39;)) %&gt;% mutate(group = str_replace(group, &#39;_asv_tcts.tsv.res$&#39;,&#39;&#39;)) # change the &quot;N&quot; direction to be minus score feature &lt;- bind_rows( feature %&gt;% split(.$direction) %&gt;% pluck(&#39;no&#39;) %&gt;% mutate(score = -score), feature %&gt;% split(.$direction) %&gt;% pluck(&#39;yes&#39;) ) %&gt;% arrange(group, feature, score) %&gt;% mutate(feature = str_replace_all(feature, &#39;^.+\\\\.&#39;, &#39;&#39;)) all_title_fs &lt;- 20 axis_text_fs &lt;- 16 CR &lt;- feature %&gt;% filter(group == &#39;cr_d100&#39;) %&gt;% ggplot(aes(x = reorder(feature, score), y = score, fill = direction)) + geom_bar( stat = &#39;identity&#39;) + coord_flip() + scale_color_manual(values = c(&#39;#925E9F&#39;, &#39;#42B540&#39;)) + scale_fill_manual(values = c(&#39;#925E9F&#39;, &#39;#42B540&#39;)) + theme_classic() + theme(axis.title.y = element_blank(), plot.title = element_text(size=all_title_fs), axis.title.x = element_text(size=axis_text_fs), axis.text.x = element_text(size=axis_text_fs), legend.position=&#39;bottom&#39;) + labs(title = str_glue(&#39;Response to CR&#39;) , y = &#39;Score&#39;) tox &lt;- feature %&gt;% filter(group == &#39;toxicity&#39;) %&gt;% ggplot(aes(x = reorder(feature, score), y = score, fill = direction)) + geom_bar(stat = &#39;identity&#39;) + coord_flip() + scale_color_manual(values = c(&#39;#0099B4&#39;, &#39;#AD002A&#39;)) + scale_fill_manual(values = c(&#39;#0099B4&#39;, &#39;#AD002A&#39;)) + theme_classic() + theme(axis.title.y = element_blank(), axis.title.x = element_text(size=axis_text_fs), plot.title = element_text(size=all_title_fs), axis.text.x = element_text(size=axis_text_fs), legend.position=&quot;bottom&quot;) + labs(title = str_glue(&#39;Response to Toxicity&#39;) , y = &#39;Score&#39;) g &lt;- cowplot::plot_grid(CR,tox, nrow = 2, align = &#39;hv&#39;, rel_heights = c(1.8,1.2), axis = &#39;b&#39;) + ggsave(&#39;figs/amplicon/16s_lefse_combined.pdf&#39;, device = &#39;pdf&#39;, height = 15, width = 15) g It is important to check the relative abundance of the significant taxa visually. # to see the relative abundance of those taxa # to get the top and bottom three taxa of the lefse results res &lt;- list.files(&#39;data/amplicon/lefse/&#39;, pattern = &#39;asv_tcts.tsv.res$&#39;, full.names = T) # gather the species level taxa in the lefse significant results res_all &lt;- res %&gt;% set_names(res) %&gt;% map(~ read_tsv(., col_names = c(&#39;feature&#39;,&#39;xx&#39;,&#39;direction&#39;,&#39;score&#39;,&#39;pval&#39;)) %&gt;% filter(!is.na(score))) %&gt;% keep(~ nrow(.) &gt; 0) %&gt;% bind_rows(.id = &#39;res&#39;) %&gt;% mutate(res = str_replace(res, &#39;^.+//&#39;,&#39;&#39;), res = str_replace(res, &#39;_asv.+$&#39;,&#39;&#39;)) %&gt;% rename(grp = res) %&gt;% filter(grp %in% c(&#39;pull_cr_d100&#39;,&#39;pull_toxicity&#39;)) %&gt;% mutate(feature = str_replace_all(feature, &#39;\\\\.&#39;,&#39;\\\\|&#39;)) %&gt;% #split(., list(.$grp, .$direction)) %&gt;% #map_dfr(~ top_n(x = ., n = 4, wt = score) %&gt;% arrange(-score)) %&gt;% # filter(str_detect(feature, &#39;s__.+$&#39;)) %&gt;% # filter(!str_detect(feature, &#39;a__.+$&#39;)) %&gt;% filter(str_detect(feature, &#39;g__.+$&#39;)) %&gt;% filter(!str_detect(feature, &#39;s__.+$&#39;)) %&gt;% mutate(feature = str_replace(feature, &#39;^.+g__&#39;,&#39;&#39;)) %&gt;% mutate(feature = str_replace(feature, &#39;_Clostridium_&#39;, &#39;[Clostridium]&#39;)) %&gt;% ungroup() # plot the relab of those taxa (at species level) in boxplot # get the species counts of the sampels cts_spp &lt;- cts_ %&gt;% full_join(annot %&gt;% select(asv_key, species), by = &#39;asv_key&#39;) %&gt;% select(-asv_key) %&gt;% gather(&#39;sampleid&#39;, &#39;relab&#39;, names(.)[1]:names(.)[ncol(.)-1]) %&gt;% group_by(sampleid, species) %&gt;% summarise(Relab = sum(relab)) %&gt;% select(sampleid, species, Relab) %&gt;% left_join(meta %&gt;% select(sampleid, cr_d100, toxicity), by = &#39;sampleid&#39;) %&gt;% ungroup() cts_genus &lt;- cts_ %&gt;% full_join(annot %&gt;% select(asv_key, genus), by = &#39;asv_key&#39;) %&gt;% select(-asv_key) %&gt;% gather(&#39;sampleid&#39;, &#39;relab&#39;, names(.)[1]:names(.)[ncol(.)-1]) %&gt;% group_by(sampleid, genus) %&gt;% summarise(Relab = sum(relab)) %&gt;% select(sampleid, genus, Relab) %&gt;% left_join(meta %&gt;% select(sampleid, cr_d100, toxicity), by = &#39;sampleid&#39;) %&gt;% ungroup() joined &lt;- cts_genus %&gt;% inner_join(res_all, by = c(&#39;genus&#39; = &#39;feature&#39;)) # finally I can do the plotting joined %&gt;% filter(grp == &#39;pull_cr_d100&#39;) %&gt;% ggboxplot(x = &#39;cr_d100&#39;, y = &#39;Relab&#39;, add = &#39;jitter&#39;, title = &#39;Outcome: cr_d100&#39;) + facet_wrap(direction ~ genus, scales=&quot;free_y&quot;) + ggsave(&#39;figs/amplicon/lefse_taxa_crd100.pdf&#39;, width = 15, height = 13) As can be observed in the boxplot, patients that had a CR have higher median relative abundance in Ruminococcus. joined %&gt;% filter(grp == &#39;pull_toxicity&#39;) %&gt;% ggboxplot(x = &#39;toxicity&#39;, y = &#39;Relab&#39;, add = &#39;jitter&#39;, title = &#39;Outcome: toxicity&#39;) + facet_wrap(direction ~ genus, scales=&quot;free_y&quot;) + ggsave(&#39;figs/amplicon/lefse_taxa_toxicity.pdf&#39;, width = 15, height = 13) As can be observed in the boxplot, patients that had a toxicity response have clearly higher median relative abundance in Bacteroides. 3.4 Fig 3D Bayesian modeling with microbiome alpha diversity as predictor The formular is: CR/Toxicity ~ alpha diversity + center library(rethinking) meta &lt;- read_csv(&#39;data/amplicon/stool/combined_2_meta.csv&#39;) %&gt;% mutate(logdiv_s = scale(log(simpson_reciprocal))) %&gt;% mutate(tox = if_else(toxicity == &#39;yes&#39;, 1, 0), cr100 = if_else(cr_d100 == &#39;yes&#39;, 1, 0), loca = if_else(center == &#39;M&#39;, 1, 2)) %&gt;% # MSK 1 ; Upenn 2 mutate(center = factor(center), toxicity = factor(toxicity, levels = c(&#39;no&#39;,&#39;yes&#39;)), cr_d100 = factor(cr_d100, levels = c(&#39;no&#39;,&#39;yes&#39;))) meta %&gt;% write_csv(&#39;data/amplicon/stool/combined_2_meta_expanded.csv&#39;) set.seed(123) dat_list &lt;- list( tox = meta$tox, crs3 = meta$crs3, cr100 = meta$cr100, location = meta$loca, logdiv_s = meta$logdiv_s ) ## Warning: Unknown or uninitialised column: `crs3`. # outcome: toxicity mtox &lt;- ulam( alist( tox ~ dbinom( 1 , p ) , logit(p) &lt;- b*logdiv_s + a[location] , b ~ dnorm( 0 , 2), a[location] ~ dnorm( 0 , 0.5 ) ) , data=dat_list , chains=4 , log_lik=TRUE , cores = 8) # make the forest plot df &lt;- precis(mtox, prob = 0.95) %&gt;% as.tibble() ## Warning: `as.tibble()` was deprecated in tibble 2.0.0. ## Please use `as_tibble()` instead. ## The signature and semantics have changed, see `?as_tibble`. ## Warning in class(x) &lt;- c(setdiff(subclass, tibble_class), tibble_class): Setting ## class(x) to multiple strings (&quot;tbl_df&quot;, &quot;tbl&quot;, ...); result will no longer be an ## S4 object df &lt;- df %&gt;% mutate(variable = &#39;simpson_reciprocal&#39;) #remove row number 1 (The intercept) df %&gt;% ggplot(aes(x = reorder(variable, mean), y = mean)) + geom_point(shape = 15, size = 4, width = 0.1, position = &quot;dodge&quot;, color=&quot;black&quot;) + geom_errorbar(aes(ymin = `2.5%`, ymax = `97.5%`), width = 0.1, size = 0.7, position = &quot;dodge&quot;, color=&quot;turquoise4&quot;) + theme(axis.title = element_text(face = &quot;bold&quot;)) + #xlab(&quot;Variables&quot;) + ylab(&quot;Coefficient with 95% CI&quot;) + coord_flip(ylim = c(-0.7, 1)) + geom_hline(yintercept = 0, color = &quot;red&quot;, size = 1) + theme(axis.title = element_text(size = 0)) + theme(axis.text = element_text(size = 14)) + labs(title = &#39;95% confidence interval of the coefficients\\nfor standardized log transformed alpha diversity when outcome is toxicity&#39;, x = &#39;&#39;, y = &#39;Association with Toxicity&#39;) + ggsave(&#39;figs/amplicon/bayesian_div_tox.pdf&#39;, width = 5, height = 4) ## Warning: Ignoring unknown parameters: width ## Warning: Width not defined. Set with `position_dodge(width = ?)` ## Warning: Width not defined. Set with `position_dodge(width = ?)` # outcome : CR_d100 mcr &lt;- ulam( alist( cr100 ~ dbinom( 1 , p ) , logit(p) &lt;- b*logdiv_s + a[location] , b ~ dnorm( 0 , 2), a[location] ~ dnorm( 0 , 0.5 ) ) , data=dat_list , chains=4 , log_lik=TRUE , cores = 8) df &lt;- precis(mcr, prob = 0.95) %&gt;% as.tibble() ## Warning in class(x) &lt;- c(setdiff(subclass, tibble_class), tibble_class): Setting ## class(x) to multiple strings (&quot;tbl_df&quot;, &quot;tbl&quot;, ...); result will no longer be an ## S4 object df &lt;- df %&gt;% mutate(variable = &#39;simpson_reciprocal&#39;) #remove row number 1 (The intercept) df %&gt;% ggplot(aes(x = reorder(variable, mean), y = mean)) + geom_point(shape = 15, size = 4, width = 0.1, position = &quot;dodge&quot;, color=&quot;black&quot;) + geom_errorbar(aes(ymin = `2.5%`, ymax = `97.5%`), width = 0.1, size = 0.7, position = &quot;dodge&quot;, color=&quot;turquoise4&quot;) + theme(axis.title = element_text(face = &quot;bold&quot;)) + xlab(&quot;Variables&quot;) + ylab(&quot;Coefficient with 95% CI&quot;) + coord_flip(ylim = c(-0.7, 1)) + geom_hline(yintercept = 0, color = &quot;red&quot;, size = 1) + theme(axis.title = element_text(size = 0)) + theme(axis.text = element_text(size = 14)) + labs(title = &#39;95% confidence interval of the coefficients\\nfor standardized log transformed alpha diversity when outcome is CR&#39;) + ggsave(&#39;figs/amplicon/bayesian_div_cr.pdf&#39;, width = 5, height = 4) ## Warning: Ignoring unknown parameters: width ## Warning: Width not defined. Set with `position_dodge(width = ?)` ## Warning: Width not defined. Set with `position_dodge(width = ?)` 3.5 Fig 3G Bayesian modeling with 5 genera abundance as predictor(outcome CR) genera &lt;- read_csv(&#39;data/amplicon/stool/combined_5_genera.csv&#39;) # do not standardize the log transformed relative abundance meta &lt;- read_csv(&#39;data/amplicon/stool/combined_2_meta_expanded.csv&#39;) %&gt;% inner_join(genera) dat_list &lt;- list( tox = meta$tox, cr100 = meta$cr100, location = meta$loca, Akkermansia = meta$Akkermansia, Bacteroides = meta$Bacteroides, Enterococcus = meta$Enterococcus, Faecalibacterium = meta$Faecalibacterium, Ruminococcus = meta$Ruminococcus ) CR ~ Akkermansia + Bacteroides + Enterococcus + Faecalibacterium + Ruminococcus + center gcr &lt;- ulam( alist( cr100 ~ dbinom( 1 , p ) , logit(p) &lt;- ba*Akkermansia + bb*Bacteroides + be*Enterococcus + bf*Faecalibacterium + br*Ruminococcus + a[location] , ba ~ dnorm( 0 , 1), bb ~ dnorm( 0 , 1), be ~ dnorm( 0 , 1), bf ~ dnorm( 0 , 1), br ~ dnorm( 0 , 1), a[location] ~ dnorm( 0 , 0.5 ) ) , data=dat_list , chains=4 , log_lik=TRUE , cores = 16) df &lt;- precis(gcr, prob = 0.95) %&gt;% as.tibble() ## Warning in class(x) &lt;- c(setdiff(subclass, tibble_class), tibble_class): Setting ## class(x) to multiple strings (&quot;tbl_df&quot;, &quot;tbl&quot;, ...); result will no longer be an ## S4 object df &lt;- df %&gt;% mutate(variable = c(&#39;Akkermansia&#39;, &#39;Bacteroides&#39;,&#39;Enterococcus&#39;,&#39;Faecalibacterium&#39;,&#39;Ruminococcus&#39;)) #remove row number 1 (The intercept) df %&gt;% ggplot(aes(x = variable, y = mean)) + geom_point(shape = 15, size = 4, width = 0.1, position = &quot;dodge&quot;, color=&quot;black&quot;) + geom_errorbar(aes(ymin = `2.5%`, ymax = `97.5%`), width = 0.1, size = 0.7, position = &quot;dodge&quot;, color=&quot;turquoise4&quot;) + theme(axis.title = element_text(face = &quot;bold&quot;)) + xlab(&quot;Variables&quot;) + ylab(&quot;Coefficient with 95% CI&quot;) + coord_flip(ylim = c(-1.5, 1.5)) + geom_hline(yintercept = 0, color = &quot;red&quot;, size = 1) + theme(axis.title = element_text(size = 0)) + theme(axis.text = element_text(size = 14)) + labs(title = &#39;CR&#39;) + ggsave(&#39;figs/amplicon/bayesian_genera_cr_log10.pdf&#39;, width = 5, height = 4) ## Warning: Ignoring unknown parameters: width ## Warning: Width not defined. Set with `position_dodge(width = ?)` ## Warning: Width not defined. Set with `position_dodge(width = ?)` 3.6 Fig3H Histogram to illustrate the predicted probability of day100 CR post &lt;- extract.samples(gcr) meta_ &lt;- meta %&gt;% select(Akkermansia:Ruminococcus) # the post coeffs in df format postdf &lt;- bind_cols(ba = post$ba, bb = post$bb, be = post$be, bf = post$bf, br = post$br, am = post$a[,1]) # use the 90% and 10% quantile patient data in terms of ruminococcus relab N &lt;- 100 # for the top and bottom quantile range of ruminococcus relab ru_top &lt;- meta_ %&gt;% filter(Ruminococcus &gt;= quantile(meta$Ruminococcus, 0.9)) ru_bot &lt;- meta_ %&gt;% filter(Ruminococcus &lt;= quantile(meta$Ruminococcus, 0.1)) # a function to calculate the predicted probability with the randomly drawn coeff from the posterior distributionn and the log10 transformed relative abundance per_pt_sample_post_prob &lt;- function(lga_, lgb_, lge_, lgf_ , lgr_){ # the input is the log relab of the 5 genera for that patient post_samp &lt;- postdf %&gt;% sample_n(size = N, replace = F) ret = pmap(post_samp, function(ba, bb, be, bf, br, am) { inv_logit( ba * lga_ + bb * lgb_ + be * lge_ + bf * lgf_ + br * lgr_ + am ) }) %&gt;% set_names(seq(1, N)) %&gt;% bind_rows() %&gt;% gather() return(ret) } # for the top quantile patients res_top &lt;- pmap(ru_top, function(Akkermansia, Bacteroides, Enterococcus, Faecalibacterium, Ruminococcus){ per_pt_sample_post_prob(Akkermansia, Bacteroides, Enterococcus, Faecalibacterium, Ruminococcus) }) %&gt;% set_names(paste(&#39;P&#39;, seq(1, nrow(ru_top)), sep = &#39;&#39;)) %&gt;% bind_rows(.id = &#39;pt&#39;) # for the bottom quantile patients res_bot &lt;- pmap(ru_bot, function(Akkermansia, Bacteroides, Enterococcus, Faecalibacterium, Ruminococcus){ per_pt_sample_post_prob(Akkermansia, Bacteroides, Enterococcus, Faecalibacterium, Ruminococcus) }) %&gt;% set_names(paste(&#39;P&#39;, seq(1, nrow(ru_bot)), sep = &#39;&#39;)) %&gt;% bind_rows(.id = &#39;pt&#39;) # plot them together in one bind_rows( res_top %&gt;% mutate(grp = &#39;high Ruminococcus&#39;), res_bot %&gt;% mutate(grp = &#39;low Ruminococcus&#39;) ) %&gt;% gghistogram(x = &#39;value&#39;,bins = 30, fill = &#39;grp&#39;, palette = &#39;nejm&#39;, color = &#39;white&#39;, add = &#39;mean&#39;, xlab = &#39;Predicted probability of CR d100&#39;, ylab = &#39;Probability density&#39;)+ ggsave(&#39;figs/predicted_CR_Ruminococcus_top_bottom_10.pdf&#39;, width = 7, height = 5) bind_rows( res_top %&gt;% mutate(grp = &#39;high Ruminococcus&#39;), res_bot %&gt;% mutate(grp = &#39;low Ruminococcus&#39;) ) %&gt;% group_by(grp) %&gt;% summarise(ave = mean(value)) ## # A tibble: 2 x 2 ## grp ave ## * &lt;chr&gt; &lt;dbl&gt; ## 1 high Ruminococcus 0.679 ## 2 low Ruminococcus 0.265 As can be observed from the histogram, when the patients have high Ruminococcus content (relative abundance in the top 10% of the current patient cohort), they are predicted to have on average a probability of 0.67 to have CR at day 100; whereas when they have low Ruminococcus content (relative abundance in the bottom 10% of the current patient cohort), they are predicted to have only on average a probability of 0.27 to have CR at day 100. 3.7 Fig 3I Bayesian modeling with 5 genera abundance as predictor(outcome toxicity) Toxicity ~ Akkermansia + Bacteroides + Enterococcus + Faecalibacterium + Ruminococcus + center gtox &lt;- ulam( alist( tox ~ dbinom( 1 , p ) , logit(p) &lt;- ba*Akkermansia + bb*Bacteroides + be*Enterococcus + bf*Faecalibacterium + br*Ruminococcus + a[location] , ba ~ dnorm( 0 , 1), bb ~ dnorm( 0 , 1), be ~ dnorm( 0 , 1), bf ~ dnorm( 0 , 1), br ~ dnorm( 0 , 1), a[location] ~ dnorm( 0 , 0.5 ) ) , data=dat_list , chains=4 , log_lik=TRUE , cores = 16) df &lt;- precis(gtox, prob = 0.95) %&gt;% as.tibble() ## Warning in class(x) &lt;- c(setdiff(subclass, tibble_class), tibble_class): Setting ## class(x) to multiple strings (&quot;tbl_df&quot;, &quot;tbl&quot;, ...); result will no longer be an ## S4 object df &lt;- df %&gt;% mutate(variable = c(&#39;Akkermansia&#39;, &#39;Bacteroides&#39;,&#39;Enterococcus&#39;,&#39;Faecalibacterium&#39;,&#39;Ruminococcus&#39;)) #remove row number 1 (The intercept) df %&gt;% ggplot(aes(x = variable, y = mean)) + geom_point(shape = 15, size = 4, width = 0.1, position = &quot;dodge&quot;, color=&quot;black&quot;) + geom_errorbar(aes(ymin = `2.5%`, ymax = `97.5%`), width = 0.1, size = 0.7, position = &quot;dodge&quot;, color=&quot;turquoise4&quot;) + theme(axis.title = element_text(face = &quot;bold&quot;)) + xlab(&quot;Variables&quot;) + ylab(&quot;Coefficient with 95% CI&quot;) + coord_flip(ylim = c(-1.5, 1.5)) + geom_hline(yintercept = 0, color = &quot;red&quot;, size = 1) + theme(axis.title = element_text(size = 0)) + theme(axis.text = element_text(size = 14)) + labs(title = &#39;Toxicity&#39;) + ggsave(&#39;figs/amplicon/bayesian_genera_tox_log10.pdf&#39;, width = 5, height = 4) ## Warning: Ignoring unknown parameters: width ## Warning: Width not defined. Set with `position_dodge(width = ?)` ## Warning: Width not defined. Set with `position_dodge(width = ?)` 3.8 Fig3J Histogram to illustrate the predicted probability of toxicity # extract posterior samples post &lt;- extract.samples(gtox) meta_ &lt;- meta %&gt;% select(Akkermansia:Ruminococcus) # the post coeffs in df format postdf &lt;- bind_cols(ba = post$ba, bb = post$bb, be = post$be, bf = post$bf, br = post$br, am = post$a[,1]) N &lt;- 100 # for the top and bottom quantile range of Bacteroides relab (top and bottom 10%) ba_top &lt;- meta_ %&gt;% filter(Bacteroides &gt;= quantile(meta$Bacteroides, 0.9)) ba_bot &lt;- meta_ %&gt;% filter(Bacteroides &lt;= quantile(meta$Bacteroides, 0.1)) # a function to calculate the predicted probability with the randomly drawn coeff from the posterior distributionn and the log10 transformed relative abundance per_pt_sample_post_prob &lt;- function(lga_, lgb_, lge_, lgf_ , lgr_){ # the input is the log relab of the 5 genera for that patient post_samp &lt;- postdf %&gt;% sample_n(size = N, replace = F) ret = pmap(post_samp, function(ba, bb, be, bf, br, am) { inv_logit( ba * lga_ + bb * lgb_ + be * lge_ + bf * lgf_ + br * lgr_ + am ) }) %&gt;% set_names(seq(1, N)) %&gt;% bind_rows() %&gt;% gather() return(ret) } # for the top quantile patients res_top &lt;- pmap(ba_top, function(Akkermansia, Bacteroides, Enterococcus, Faecalibacterium, Ruminococcus){ per_pt_sample_post_prob(Akkermansia, Bacteroides, Enterococcus, Faecalibacterium, Ruminococcus) }) %&gt;% set_names(paste(&#39;P&#39;, seq(1, nrow(ba_top)), sep = &#39;&#39;)) %&gt;% bind_rows(.id = &#39;pt&#39;) # for the bottom quantile patients res_bot &lt;- pmap(ba_bot, function(Akkermansia, Bacteroides, Enterococcus, Faecalibacterium, Ruminococcus){ per_pt_sample_post_prob(Akkermansia, Bacteroides, Enterococcus, Faecalibacterium, Ruminococcus) }) %&gt;% set_names(paste(&#39;P&#39;, seq(1, nrow(ba_bot)), sep = &#39;&#39;)) %&gt;% bind_rows(.id = &#39;pt&#39;) # plot them together in one bind_rows( res_top %&gt;% mutate(grp = &#39;top&#39;), res_bot %&gt;% mutate(grp = &#39;bot&#39;) ) %&gt;% gghistogram(x = &#39;value&#39;,bins = 30, fill = &#39;grp&#39;, palette = &#39;nejm&#39;, color = &#39;white&#39;, add = &#39;mean&#39;, xlab = &#39;Predicted probability of Toxicity&#39;, ylab = &#39;Probability density&#39;) + ggsave(&#39;figs/predicted_tox_bacteroides_top_bottom_10.pdf&#39;, width = 7, height = 5) As can be observed from the histogram, when the patients have high Bacteroides content (relative abundance in the top 10% of the current patient cohort), they are predicted to almost always have a toxicity response: the histogram amassed on the right side of 0.5; whereas when the patients have low Bacteroides content (relative abundance in the bottom 10% of the current patient cohort), the patients are predicted to have no inclination towards whether or not to have a toxicity response. 3.9 Fig 3K lefse of pathway abundance using shotgun data simple &lt;- read_csv(&#39;data/shotgun/final_comprehensive_UPDATED_simple.csv&#39;) pheno &lt;- simple %&gt;% gather(&#39;pheno&#39;, &#39;value&#39;, cr_d100:toxicity) # the pathway counts table full &lt;- read_tsv(&#39;data/shotgun/humann3_pathabundance_cpm_joined_unstratified.tsv&#39;) %&gt;% rename_all(funs(str_replace(., &#39;^CART_&#39;,&#39;&#39;))) %&gt;% rename_all(funs(str_replace(., &#39;_humann3$&#39;,&#39;&#39;))) ## Warning: `funs()` was deprecated in dplyr 0.8.0. ## Please use a list of either functions or lambdas: ## ## # Simple named list: ## list(mean = mean, median = median) ## ## # Auto named with `tibble::lst()`: ## tibble::lst(mean, median) ## ## # Using lambdas ## list(~ mean(., trim = .2), ~ median(., na.rm = TRUE)) all_sub_pheno &lt;- pheno %&gt;% split(., list(.$pheno)) %&gt;% purrr::imap(~ filter(.data = ., value != &#39;not_assessed&#39;)) all_sub_pheno %&gt;% imap(function(.x, .y){ select(.data = .x, value) %&gt;% t() %&gt;% write.table(str_glue(&#39;data/shotgun/pull_{.y}.txt&#39;), sep = &#39;\\t&#39;, quote = F, row.names = T, col.names = F) }) ## $cr_d100 ## NULL ## ## $toxicity ## NULL all_pcts &lt;- all_sub_pheno %&gt;% purrr::map(~ pull(.data = ., fid) ) %&gt;% imap(~ full %&gt;% select(`# Pathway`, matches(.x)) %&gt;% write_tsv(str_glue(&#39;data/shotgun/pull_{.y}_pcts.tsv&#39;))) # then move to Snakemake do the normalization and the split # add a filtering step here # 50 and 25% pcts &lt;- read_tsv(&#39;data/shotgun/pull_cr_d100_pcts_cpm_unstratified.tsv&#39;) %&gt;% gather(&#39;sampleid&#39;, &#39;cpm&#39;, names(.)[2]:names(.)[ncol(.)]) %&gt;% rename(pw = `# Pathway`) keeppw &lt;- pcts %&gt;% filter(cpm &gt; 50) %&gt;% ungroup() %&gt;% count(pw) %&gt;% filter(n &gt; floor(nrow(simple) * 0.25)) %&gt;% pull(pw) cts_fil &lt;- pcts %&gt;% filter(pw %in% keeppw) %&gt;% spread(&#39;sampleid&#39;, &#39;cpm&#39;, fill = 0) cts_fil %&gt;% write_tsv(&#39;data/shotgun/pull_cr_d100_pcts_cpm_unstratified_fil.tsv&#39;) # tox pcts &lt;- read_tsv(&#39;data/shotgun/pull_toxicity_pcts_cpm_unstratified.tsv&#39;) %&gt;% gather(&#39;sampleid&#39;, &#39;cpm&#39;, names(.)[2]:names(.)[ncol(.)]) %&gt;% rename(pw = `# Pathway`) keeppw &lt;- pcts %&gt;% filter(cpm &gt; 50) %&gt;% ungroup() %&gt;% count(pw) %&gt;% filter(n &gt; floor(nrow(simple) * 0.25)) %&gt;% pull(pw) cts_fil &lt;- pcts %&gt;% filter(pw %in% keeppw) %&gt;% spread(&#39;sampleid&#39;, &#39;cpm&#39;, fill = 0) cts_fil %&gt;% write_tsv(&#39;data/shotgun/pull_toxicity_pcts_cpm_unstratified_fil.tsv&#39;) # PATHWAY # I already normalized the pcts so don&#39;t need to normalize again here fns &lt;- list.files(&#39;data/shotgun/&#39;, pattern = &#39;lefse_ready_pcts.tsv$&#39;) cmds &lt;- tibble( fns = fns ) %&gt;% mutate(format_cmd = str_glue(&#39;lefse_format_input.py {fns} {fns}.in -c 1 -u 2&#39;)) %&gt;% mutate(run_cmd = str_glue(&#39;lefse_run.py {fns}.in {fns}.res&#39;)) %&gt;% mutate(plot_cmd = str_glue(&#39;lefse_plot_res.py {fns}.res {fns}.pdf --format pdf --feature_font_size 4 --width 10 --dpi 300 --title {fns}&#39;)) %&gt;% select(-fns) %&gt;% gather() %&gt;% select(value) %&gt;% write_csv(&#39;data/shotgun/lefse_run_cmd.sh&#39;, col_names = F) # look at the pathway results library(vdbR) connect_database(&#39;~/dbConfig.txt&#39;) get_table_from_database(&#39;metacyc_pathway_name&#39;) get_table_from_database(&#39;metacyc_pathway_ontology&#39;) fns &lt;- list.files(&#39;data/shotgun/&#39;, pattern = &#39;lefse_ready_pcts.tsv.res$&#39;, full.names = T) feature &lt;- fns %&gt;% set_names(fns) %&gt;% purrr::map(~ read_tsv(., col_names = c(&#39;pathway&#39;,&#39;xx&#39;,&#39;direction&#39;,&#39;score&#39;,&#39;pval&#39;)) %&gt;% filter(!is.na(score))) %&gt;% bind_rows(.id = &#39;group&#39;) %&gt;% mutate(group = str_replace(group, &#39;data/shotgun//&#39;,&#39;&#39;)) %&gt;% mutate(group = str_replace(group, &#39;_lefse_ready_pcts.tsv.res$&#39;,&#39;&#39;)) # change the &quot;N&quot; direction to be minus score feature &lt;- bind_rows( feature %&gt;% split(.$direction) %&gt;% pluck(&#39;no&#39;) %&gt;% mutate(score = -score), feature %&gt;% split(.$direction) %&gt;% pluck(&#39;yes&#39;) ) %&gt;% arrange(group, pathway, score) %&gt;% mutate(pwid = str_extract(pathway, &#39;^.+_PWY|^PWY.*_\\\\d{3,4}&#39;)) %&gt;% mutate(pwid = str_replace_all(pwid, &#39;_&#39;, &#39;-&#39;)) %&gt;% mutate(pwid = if_else(str_detect(pathway, &#39;^TCA&#39;), &#39;TCA&#39;, pwid)) %&gt;% mutate(pwid = if_else(str_detect(pathway, &#39;^NAD&#39;), &#39;NAD-BIOSYNTHESIS-II&#39;, pwid)) %&gt;% inner_join(metacyc_pathway_name %&gt;% select(pwid, pw_name)) %&gt;% inner_join(metacyc_pathway_ontology %&gt;% select(pwid, l4:l9)) all_title_fs &lt;- 20 axis_text_fs &lt;- 16 CR &lt;- feature %&gt;% filter(group == &#39;pull_cr_d100&#39;) %&gt;% ggplot(aes(x = reorder(pathway, score), y = score, fill = direction)) + geom_bar( stat = &#39;identity&#39;) + coord_flip() + scale_color_manual(values = c(&#39;#925E9F&#39;, &#39;#42B540&#39;)) + scale_fill_manual(values = c(&#39;#925E9F&#39;, &#39;#42B540&#39;)) + theme_classic() + theme(axis.title.y = element_blank(), plot.title = element_text(size=all_title_fs), axis.title.x = element_text(size=axis_text_fs), axis.text.x = element_text(size=axis_text_fs), legend.position=&#39;bottom&#39;) + labs(title = str_glue(&#39;Response to CR&#39;) , y = &#39;Score&#39;) tox &lt;- feature %&gt;% filter(group == &#39;pull_toxicity&#39;) %&gt;% ggplot(aes(x = reorder(pathway, score), y = score, fill = direction)) + geom_bar(stat = &#39;identity&#39;) + coord_flip() + scale_color_manual(values = c(&#39;#0099B4&#39;, &#39;#AD002A&#39;)) + scale_fill_manual(values = c(&#39;#0099B4&#39;, &#39;#AD002A&#39;)) + theme_classic() + theme(axis.title.y = element_blank(), axis.title.x = element_text(size=axis_text_fs), plot.title = element_text(size=all_title_fs), axis.text.x = element_text(size=axis_text_fs), legend.position=&quot;bottom&quot;) + labs(title = str_glue(&#39;Response to Toxicity&#39;) , y = &#39;Score&#39;) cowplot::plot_grid(CR,tox, nrow = 2, rel_heights = c(1,3), align = &#39;hv&#39;, axis = &#39;b&#39;) "],["methods.html", "Chapter 4 Methods", " Chapter 4 Methods We describe our methods in this chapter. "],["applications.html", "Chapter 5 Applications 5.1 Example one 5.2 Example two", " Chapter 5 Applications Some significant applications are demonstrated in this chapter. 5.1 Example one 5.2 Example two "],["final-words.html", "Chapter 6 Final Words", " Chapter 6 Final Words We have finished a nice book. "],["references.html", "References", " References "]]
